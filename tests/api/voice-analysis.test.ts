/**
 * TestSprite Generated Tests: Voice Analysis API
 * Critical Priority: P0 - Core biomarker processing functionality
 * Generated by: TestSprite MCP v1.0.0
 */

import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { NextRequest } from 'next/server';
import { GET, POST } from '../../heartvoice-monitor/src/app/api/voice-analysis/route';

describe('Voice Analysis API - Critical Tests', () => {
  let mockRequest: Partial<NextRequest>;

  beforeEach(() => {
    mockRequest = {
      url: 'http://localhost:3002/api/voice-analysis',
      method: 'GET'
    };
  });

  describe('GET /api/voice-analysis', () => {
    test('should return all voice analysis results when no filters applied', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data).toHaveProperty('total');
      expect(data).toHaveProperty('results');
      expect(Array.isArray(data.results)).toBe(true);
      expect(data.total).toBeGreaterThan(0);
    });

    test('should filter results by patient ID', async () => {
      const patientId = 'patient-1758211577297-l6y2zg7gt';
      const request = new NextRequest(`http://localhost:3002/api/voice-analysis?patientId=${patientId}`);
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.results.every((result: any) => result.patientId === patientId)).toBe(true);
    });

    test('should validate biomarker data structure', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      expect(data.results.length).toBeGreaterThan(0);
      
      const result = data.results[0];
      expect(result).toHaveProperty('biomarkers');
      expect(result.biomarkers).toHaveProperty('jitter');
      expect(result.biomarkers).toHaveProperty('shimmer');
      expect(result.biomarkers).toHaveProperty('hnr');
      expect(result.biomarkers).toHaveProperty('f0');
      expect(result.biomarkers).toHaveProperty('prosody');
      expect(result.biomarkers).toHaveProperty('spectral');
    });

    test('should validate clinical risk score ranges', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      data.results.forEach((result: any) => {
        expect(result.riskScore).toBeGreaterThanOrEqual(0);
        expect(result.riskScore).toBeLessThanOrEqual(100);
        expect(typeof result.riskScore).toBe('number');
      });
    });

    test('should include transcript data for clinical review', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      data.results.forEach((result: any) => {
        expect(result).toHaveProperty('transcript');
        expect(typeof result.transcript).toBe('string');
        expect(result.transcript.length).toBeGreaterThan(0);
      });
    });

    test('should validate biomarker clinical ranges', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      data.results.forEach((result: any) => {
        const { biomarkers } = result;
        
        // Jitter validation (normal < 1.04%, pathological > 2.5%)
        expect(biomarkers.jitter.local).toBeGreaterThan(0);
        expect(biomarkers.jitter.local).toBeLessThan(0.1); // 10% max sanity check
        
        // Shimmer validation (normal < 0.35 dB, pathological > 1.0 dB)
        expect(biomarkers.shimmer.local).toBeGreaterThan(0);
        expect(biomarkers.shimmer.local).toBeLessThan(0.2); // 20% max sanity check
        
        // HNR validation (normal > 15 dB)
        expect(biomarkers.hnr.mean).toBeGreaterThan(0);
        expect(biomarkers.hnr.mean).toBeLessThan(30); // 30 dB max sanity check
        
        // F0 validation (typical human range 80-300 Hz)
        expect(biomarkers.f0.mean).toBeGreaterThan(50);
        expect(biomarkers.f0.mean).toBeLessThan(500);
      });
    });
  });

  describe('POST /api/voice-analysis - Voice Recording Processing', () => {
    test('should process voice recording and generate biomarkers', async () => {
      const mockFormData = new FormData();
      mockFormData.append('patientId', 'patient-test-123');
      mockFormData.append('question', 'symptoms');
      mockFormData.append('RecordingUrl', 'https://api.twilio.com/test-recording');
      mockFormData.append('RecordingSid', 'RE123456789');
      mockFormData.append('RecordingDuration', '30');

      const request = new NextRequest('http://localhost:3002/api/voice-analysis', {
        method: 'POST',
        body: mockFormData
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data).toHaveProperty('success', true);
      expect(data).toHaveProperty('analysisId');
    });

    test('should handle missing required parameters', async () => {
      const mockFormData = new FormData();
      // Missing patientId

      const request = new NextRequest('http://localhost:3002/api/voice-analysis', {
        method: 'POST',
        body: mockFormData
      });

      const response = await POST(request);
      
      expect(response.status).toBe(400);
    });

    test('should validate recording duration limits', async () => {
      const mockFormData = new FormData();
      mockFormData.append('patientId', 'patient-test-123');
      mockFormData.append('question', 'symptoms');
      mockFormData.append('RecordingDuration', '300'); // 5 minutes - too long

      const request = new NextRequest('http://localhost:3002/api/voice-analysis', {
        method: 'POST',
        body: mockFormData
      });

      const response = await POST(request);
      
      // Should either accept or reject based on business rules
      expect([200, 400]).toContain(response.status);
    });
  });

  describe('Performance Tests', () => {
    test('should respond within acceptable time limits', async () => {
      const startTime = Date.now();
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const endTime = Date.now();

      expect(response.status).toBe(200);
      expect(endTime - startTime).toBeLessThan(2000); // 2 second max for clinical use
    });

    test('should handle concurrent requests efficiently', async () => {
      const requests = Array(5).fill(null).map(() => 
        GET(new NextRequest('http://localhost:3002/api/voice-analysis'))
      );

      const responses = await Promise.all(requests);
      
      responses.forEach(response => {
        expect(response.status).toBe(200);
      });
    });
  });

  describe('Data Integrity Tests', () => {
    test('should maintain consistent data structure across results', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      const requiredFields = ['patientId', 'patientName', 'callSid', 'timestamp', 'biomarkers', 'riskScore'];
      
      data.results.forEach((result: any) => {
        requiredFields.forEach(field => {
          expect(result).toHaveProperty(field);
        });
      });
    });

    test('should ensure timestamp consistency and ordering', async () => {
      const request = new NextRequest('http://localhost:3002/api/voice-analysis');
      const response = await GET(request);
      const data = await response.json();

      data.results.forEach((result: any) => {
        const timestamp = new Date(result.timestamp);
        expect(timestamp.getTime()).not.toBeNaN();
        expect(timestamp.getTime()).toBeLessThanOrEqual(Date.now());
      });
    });
  });
});
